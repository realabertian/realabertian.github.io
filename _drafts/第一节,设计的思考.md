---
layout: post
title:  "Glide研究: 1.图片加载的设计思考"
date:   2020-08-04 19:32:53 +0800
categories: Glide
---

## 图片加载面临的问题

在开始着手进行Glide源码分析之前,我的老规矩是先来审视一下面临的问题是什么.
我们从最基本的事情开始说起——抛开外部框架——在android中将图片显示出来最简单的流程是什么?
```Java
ImageView view = findViewById(R.id.image_view);
view.setImageResource(R.drawable.my_image)

```

上面的的代码可以简述为以下两个步骤:

- 找到显示图片的View
- 将图片设置到View中

尽管上述流程确实可以成功实现图片显示,但是事情往往并不会如此简单

---

## 一点变化产生的问题
我们实际开发中首要面对的一个非常常见的问题是图片来自于网络下载,此种场景下我们需要先将要显示的图片下载到本地,然后再设置到相应的View中,也就是如下步骤:

- 下载图片
- 找到显示图片的View
- 将图片设置到View中

看起来这样子规划确实能够满足需求,但是如果你实际运行这种流程的代码,你会发现一个问题, 由于下载下来的图片其占用过多的内存导致加载显示很慢,甚至导致内存溢出的异常, 于是你得想办法优化一下,优化的思路也非常简单,就是根据View的显示大小来按需取用下载的图片的尺寸.比如 显示View实际是100*100的像素大小, 而图片是1080*1080,那么可以简单对图片进行缩放采样一获取一个100*100的采样显示在View中我们可以将这个过程简称为decode,于是我们的流程优化成如下:

- 下载图片
- 找到显示View
- 使用显示View的Size进行decode
- 将decode后的图片设置到View中

当你将上述的流程固定为代码后,你又会发现一个新问题——每次请求同一个网络地址的图片都会执行一次请求网络,这样是非常浪费数据流量以及电池寿命的,怎么优化呢?很简单,就是缓存机制. 你依据某个key来表示缓存中的图片,比如使用图片请求的URL, 第一次下载时将下载后的图片以及其保存在本地的地址保存在一个缓存记录表中以key为查询条件,当用户使用URL请求该图片,代码首先去查看缓存记录表中是否已经缓存了这个图片,如果已经缓存了,那么就是直接从缓存表中拿到本地的图片执行接下来的操作.如果没有就先下载图片,完成后添加缓存记录到缓存表中,再执行之后的操作,于是图片加载的逻辑再次优化为如下的流程:

- 查看缓存
- 有缓存则跳过此步骤,没有则下载图片
- 找到显示的View
- 使用显示View的Size进行decode
- 将decode后的图片设置到View中

上面的流程看上去如何,能够再进一步优化吗?答案是肯定的,我们发现decode后的图片其实也可以缓存起来,这样子下次如果是同一个大小的View就不需要再进行一次decode过程了,直接从decode缓存中获取图片设置到View中,于是我们的流程进一步优化如下:

- 检查缓存
- 有缓存跳过此步骤,没有则下载图片
- 找到显示的View
- 使用显示的View的Size查询decode缓存
- 如果找到则跳过此步,否则进行decode并缓存decode结果
- 从decode缓存中取出图片设置到目标View中

